// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named

part of 'session_details_global.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

mixin _$UserResultType {
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result min(),
    @required Result mean(),
    @required Result max(),
  });

  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result min(),
    Result mean(),
    Result max(),
    @required Result orElse(),
  });

  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result min(UserResultMin value),
    @required Result mean(UserResultMean value),
    @required Result max(UserResultMax value),
  });

  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result min(UserResultMin value),
    Result mean(UserResultMean value),
    Result max(UserResultMax value),
    @required Result orElse(),
  });
}

class _$UserResultTypeTearOff {
  const _$UserResultTypeTearOff();

  UserResultMin min() {
    return const UserResultMin();
  }

  UserResultMean mean() {
    return const UserResultMean();
  }

  UserResultMax max() {
    return const UserResultMax();
  }
}

const $UserResultType = _$UserResultTypeTearOff();

class _$UserResultMin with DiagnosticableTreeMixin implements UserResultMin {
  const _$UserResultMin();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'UserResultType.min()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties..add(DiagnosticsProperty('type', 'UserResultType.min'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is UserResultMin);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result min(),
    @required Result mean(),
    @required Result max(),
  }) {
    assert(min != null);
    assert(mean != null);
    assert(max != null);
    return min();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result min(),
    Result mean(),
    Result max(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (min != null) {
      return min();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result min(UserResultMin value),
    @required Result mean(UserResultMean value),
    @required Result max(UserResultMax value),
  }) {
    assert(min != null);
    assert(mean != null);
    assert(max != null);
    return min(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result min(UserResultMin value),
    Result mean(UserResultMean value),
    Result max(UserResultMax value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (min != null) {
      return min(this);
    }
    return orElse();
  }
}

abstract class UserResultMin implements UserResultType {
  const factory UserResultMin() = _$UserResultMin;
}

class _$UserResultMean with DiagnosticableTreeMixin implements UserResultMean {
  const _$UserResultMean();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'UserResultType.mean()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties..add(DiagnosticsProperty('type', 'UserResultType.mean'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is UserResultMean);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result min(),
    @required Result mean(),
    @required Result max(),
  }) {
    assert(min != null);
    assert(mean != null);
    assert(max != null);
    return mean();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result min(),
    Result mean(),
    Result max(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (mean != null) {
      return mean();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result min(UserResultMin value),
    @required Result mean(UserResultMean value),
    @required Result max(UserResultMax value),
  }) {
    assert(min != null);
    assert(mean != null);
    assert(max != null);
    return mean(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result min(UserResultMin value),
    Result mean(UserResultMean value),
    Result max(UserResultMax value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (mean != null) {
      return mean(this);
    }
    return orElse();
  }
}

abstract class UserResultMean implements UserResultType {
  const factory UserResultMean() = _$UserResultMean;
}

class _$UserResultMax with DiagnosticableTreeMixin implements UserResultMax {
  const _$UserResultMax();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'UserResultType.max()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties..add(DiagnosticsProperty('type', 'UserResultType.max'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is UserResultMax);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result min(),
    @required Result mean(),
    @required Result max(),
  }) {
    assert(min != null);
    assert(mean != null);
    assert(max != null);
    return max();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result min(),
    Result mean(),
    Result max(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (max != null) {
      return max();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result min(UserResultMin value),
    @required Result mean(UserResultMean value),
    @required Result max(UserResultMax value),
  }) {
    assert(min != null);
    assert(mean != null);
    assert(max != null);
    return max(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result min(UserResultMin value),
    Result mean(UserResultMean value),
    Result max(UserResultMax value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (max != null) {
      return max(this);
    }
    return orElse();
  }
}

abstract class UserResultMax implements UserResultType {
  const factory UserResultMax() = _$UserResultMax;
}
